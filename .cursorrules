# GAIME - AI Text Adventure Engine

## Folder Guidance

- **`/docs`** - Reference documentation including VISION.md. Consult these files proactively when working on related features.
- **`/docs/STYLE_AUTHORING.md`** - How to create visual style presets for image generation (MPA architecture).
- **`/planning`** - Development roadmap and progress tracking. Consult proactively and update when implementing features.
- **`/ideas`** - Personal brainstorming and notes. Do NOT use as reference or context unless the user explicitly asks to work with a specific file from this folder.
- **`/backend/app/llm/prompts/image_generator/presets/`** - Visual style presets. See `README.md` in that folder for quick template when creating new presets.


## Project Overview

GAIME is an AI-powered text adventure game engine that combines classic text-based gameplay with modern LLM capabilities. The AI acts as a dynamic game master, generating rich narrative responses while maintaining game state consistency.

## Architecture

### Tech Stack
- **Backend**: Python 3.11+ with FastAPI
- **Frontend**: Vite + React + TypeScript + Tailwind CSS
- **LLM**: LiteLLM (provider-agnostic, default: Google Gemini)
- **World Data**: YAML files for game content definition
- **State**: In-memory with optional persistence

### Project Structure
```
gaime/
├── backend/          # Python FastAPI server
│   └── app/
│       ├── api/      # REST endpoints
│       ├── engine/   # Game logic
│       ├── llm/      # LLM integration
│       └── models/   # Pydantic schemas
├── frontend/         # React application
│   └── src/
│       ├── components/
│       ├── hooks/
│       └── api/
├── worlds/           # YAML world definitions
├── docs/             # Developer documentation
└── PLAN.md           # Implementation roadmap
```

## Core Concepts

### Hybrid World-Building
We use a hybrid approach to world creation:
1. **Authored Skeleton**: Key locations, major NPCs, plot constraints defined in YAML
2. **AI Enhancement**: LLM generates narrative details, dialogue, atmosphere at runtime
3. **AI-Assisted Authoring**: World builder tool helps create YAML content from prompts

### Two AI Modes
1. **Game Master (Runtime)**: Processes player actions, generates narrative, updates state
2. **World Builder (Authoring)**: Generates world content from high-level descriptions

### World Definition Schema
- `world.yaml`: Theme, premise, player setup, global constraints
  - **`starting_situation`**: Explains WHY the player can act now (critical for immersion)
  - **`victory`**: Win condition with `location`, `flag`, `item`, and `narrative` fields
- `locations.yaml`: Rooms with atmosphere hints, exits, items, interactions
  - **Exit details**: Add details for each exit direction (e.g., `north: "A door leads north"`)
- `npcs.yaml`: Characters with personality, knowledge, behavior rules
- `items.yaml`: Objects with descriptions, uses, puzzle connections
  - **`found_description`**: REQUIRED - How item appears in scene (makes items discoverable)

## Coding Conventions

### Python (Backend)
- Use type hints everywhere
- Pydantic models for all data structures
- Async endpoints in FastAPI
- Keep game logic in `engine/`, LLM logic in `llm/`

### TypeScript (Frontend)
- Functional components with hooks
- Custom hooks for shared logic (e.g., `useGame`)
- Tailwind for styling, no CSS files
- Keep API calls in `api/client.ts`

### YAML World Files
- Use descriptive keys (e.g., `entrance_hall` not `room1`)
- Include `atmosphere` hints for AI narrative generation
- Define `constraints` for game rules the AI must follow

## Key Design Decisions

1. **Provider-Agnostic LLM**: LiteLLM abstracts provider differences; switch via env var
2. **Structured AI Responses**: LLM returns JSON with narrative + state changes
3. **State in System Prompt**: Each request includes current game state for consistency
4. **YAML for Content**: Human-readable, version-controlled, easy to edit

## Common Tasks

### Adding a New World
1. Create folder in `worlds/[world-name]/`
2. Add `world.yaml`, `locations.yaml`, `npcs.yaml`, `items.yaml`
3. Follow schema in `docs/WORLD_AUTHORING.md`

### Switching LLM Provider
Set environment variable: `LLM_PROVIDER=openai` or `anthropic` or `gemini`

### Running the Project
```bash
# Backend
cd backend && pip install -r requirements.txt && uvicorn app.main:app --reload

# Frontend
cd frontend && npm install && npm run dev
```

## Documentation
- `docs/ARCHITECTURE.md` - System design and data flow
- `docs/WORLD_AUTHORING.md` - How to create game worlds
- `docs/LLM_INTEGRATION.md` - AI prompts and provider setup
- `docs/API.md` - Backend API reference

## Documentation Maintenance (IMPORTANT)

When making code changes, **always check if documentation needs updating**:

| Change Type | Docs to Update |
|-------------|----------------|
| New/changed API endpoints | `docs/API.md` |
| New/changed Pydantic models | `docs/API.md` (Data Models section) |
| Changes to game state schema | `docs/ARCHITECTURE.md`, `docs/API.md` |
| New world.yaml fields | `docs/WORLD_AUTHORING.md` |
| New locations.yaml fields | `docs/WORLD_AUTHORING.md` |
| New items.yaml fields | `docs/WORLD_AUTHORING.md` |
| New npcs.yaml fields | `docs/WORLD_AUTHORING.md` |
| Changes to LLM prompts | `docs/LLM_INTEGRATION.md` |
| New game mechanics (victory, etc.) | `docs/ARCHITECTURE.md`, `docs/WORLD_AUTHORING.md` |
| World builder changes | `docs/LLM_INTEGRATION.md` |
| Implementing a feature from backlog | `planning/roadmap.md` |
| Completing a roadmap phase item | `planning/roadmap.md` |
| World schema model changes (`models/world.py`) | `gaime_builder/core/prompts/world_builder/*.txt` |
| New NPC/Item/Location fields | Update prompt examples + `docs/WORLD_AUTHORING.md` |

### Docs/Planning/Ideas index upkeep
- Whenever adding, renaming, or removing files in `docs/`, update the table in `docs/index.md` to list the current files with brief descriptions.
- Whenever adding, renaming, or removing files in `planning/`, update the table in `planning/index.md` similarly.
- Whenever adding, renaming, or removing files in `ideas/`, update the table in `ideas/index.md` similarly (keep descriptions concise).

### Key Documentation Locations

**World Schema Fields** (when adding to world.yaml):
- `docs/WORLD_AUTHORING.md` → "world.yaml" section
- Key fields: `starting_situation`, `victory`, `constraints`

**Game State Fields** (when adding to GameState):
- `docs/ARCHITECTURE.md` → "State Schema" section
- `docs/API.md` → "GameState" interface

**API Response Fields** (when changing ActionResponse, etc.):
- `docs/API.md` → relevant endpoint section and "Data Models" section

**LLM Prompts** (when changing SYSTEM_PROMPT, OPENING_PROMPT, etc.):
- `docs/LLM_INTEGRATION.md` → "Prompt Architecture" section

