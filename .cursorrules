# GAIME - AI Text Adventure Engine

## Folder Guidance

- **`/docs`** - Reference documentation including VISION.md. Consult these files proactively when working on related features.
- **`/docs/STYLE_AUTHORING.md`** - How to create visual style presets for image generation (MPA architecture).
- **`/planning`** - Development roadmap and progress tracking. Consult proactively and update when implementing features.
- **`/ideas`** - Personal brainstorming and notes. Do NOT use as reference or context unless the user explicitly asks to work with a specific file from this folder.
- **`/gaime_builder/core/prompts/image_generator/presets/`** - Visual style presets. See `docs/STYLE_AUTHORING.md` for documentation on creating new presets.


## Project Overview

GAIME is an AI-powered text adventure game engine that combines classic text-based gameplay with modern LLM capabilities. The AI acts as a dynamic game master, generating rich narrative responses while maintaining game state consistency.

## Architecture

### Tech Stack
- **Backend**: Python 3.11+ with FastAPI
- **Frontend**: Vite + React + TypeScript + Tailwind CSS
- **LLM**: LiteLLM (provider-agnostic, default: Google Gemini)
- **World Data**: YAML files for game content definition
- **State**: In-memory with optional persistence

### Project Structure
```
gaime/
├── backend/          # Python FastAPI server
│   └── app/
│       ├── api/      # REST endpoints
│       ├── engine/   # Game logic
│       ├── llm/      # LLM integration
│       └── models/   # Pydantic schemas
├── frontend/         # React application
│   └── src/
│       ├── components/
│       ├── hooks/
│       └── api/
├── worlds/           # YAML world definitions
├── docs/             # Developer documentation
└── PLAN.md           # Implementation roadmap
```

## Core Concepts

### Hybrid World-Building
We use a hybrid approach to world creation:
1. **Authored Skeleton**: Key locations, major NPCs, plot constraints defined in YAML
2. **AI Enhancement**: LLM generates narrative details, dialogue, atmosphere at runtime
3. **AI-Assisted Authoring**: World builder tool helps create YAML content from prompts

### Two AI Modes
1. **Game Master (Runtime)**: Processes player actions, generates narrative, updates state
2. **World Builder (Authoring)**: Generates world content from high-level descriptions

### World Definition Schema
- `world.yaml`: Theme, premise, player setup, global constraints
  - **`starting_situation`**: Explains WHY the player can act now (critical for immersion)
  - **`victory`**: Win condition with `location`, `flag`, `item`, and `narrative` fields
- `locations.yaml`: Rooms with atmosphere hints, exits, items, interactions
  - **Exit details**: Add details for each exit direction (e.g., `north: "A door leads north"`)
- `npcs.yaml`: Characters with personality, knowledge, behavior rules
- `items.yaml`: Objects with descriptions, uses, puzzle connections
  - **`found_description`**: REQUIRED - How item appears in scene (makes items discoverable)

## Coding Conventions

### Python (Backend)
- Use type hints everywhere
- Pydantic models for all data structures
- Async endpoints in FastAPI
- Keep game logic in `engine/`, LLM logic in `llm/`

### TypeScript (Frontend)
- Functional components with hooks
- Custom hooks for shared logic (e.g., `useGame`)
- Tailwind for styling, no CSS files
- Keep API calls in `api/client.ts`

### YAML World Files
- Use descriptive keys (e.g., `entrance_hall` not `room1`)
- Include `atmosphere` hints for AI narrative generation
- Define `constraints` for game rules the AI must follow

## Key Design Decisions

1. **Provider-Agnostic LLM**: LiteLLM abstracts provider differences; switch via env var
2. **Structured AI Responses**: LLM returns JSON with narrative + state changes
3. **State in System Prompt**: Each request includes current game state for consistency
4. **YAML for Content**: Human-readable, version-controlled, easy to edit

## Common Tasks

### Adding a New World
1. Create folder in `worlds/[world-name]/`
2. Add `world.yaml`, `locations.yaml`, `npcs.yaml`, `items.yaml`
3. Follow schema in `docs/WORLD_AUTHORING.md`

### Switching LLM Provider
Set environment variable: `LLM_PROVIDER=openai` or `anthropic` or `gemini`

### Running the Project
```bash
# Backend
cd backend && pip install -r requirements.txt && uvicorn app.main:app --reload

# Frontend
cd frontend && npm install && npm run dev
```

## Documentation
- `docs/ARCHITECTURE.md` - System design and data flow
- `docs/WORLD_AUTHORING.md` - How to create game worlds
- `docs/LLM_INTEGRATION.md` - AI prompts and provider setup
- `docs/API.md` - Backend API reference

## Documentation Maintenance (IMPORTANT)

When making code changes, **always check if documentation needs updating**:

| Change Type | Docs to Update |
|-------------|----------------|
| New/changed API endpoints | `docs/API.md` |
| New/changed Pydantic models | `docs/API.md` (Data Models section) |
| Changes to game state schema | `docs/ARCHITECTURE.md`, `docs/API.md` |
| New world.yaml fields | `docs/WORLD_AUTHORING.md` |
| New locations.yaml fields | `docs/WORLD_AUTHORING.md` |
| New items.yaml fields | `docs/WORLD_AUTHORING.md` |
| New npcs.yaml fields | `docs/WORLD_AUTHORING.md` |
| Changes to LLM prompts | `docs/LLM_INTEGRATION.md` |
| New game mechanics (victory, etc.) | `docs/ARCHITECTURE.md`, `docs/WORLD_AUTHORING.md` |
| World builder changes | `docs/LLM_INTEGRATION.md` |
| Implementing a feature from backlog | `planning/roadmap.md` |
| Completing a roadmap phase item | `planning/roadmap.md` |
| World schema model changes (`models/world.py`) | `gaime_builder/core/prompts/world_builder/*.txt` |
| New NPC/Item/Location fields | Update prompt examples + `docs/WORLD_AUTHORING.md` |

### Docs/Planning/Ideas index upkeep
- Whenever adding, renaming, or removing files in `docs/`, update the table in `docs/index.md` to list the current files with brief descriptions.
- Whenever adding, renaming, or removing files in `planning/`, update the table in `planning/index.md` similarly.
- Whenever adding, renaming, or removing files in `ideas/`, update the table in `ideas/index.md` similarly (keep descriptions concise).

### Key Documentation Locations

**World Schema Fields** (when adding to world.yaml):
- `docs/WORLD_AUTHORING.md` → "world.yaml" section
- Key fields: `starting_situation`, `victory`, `constraints`

**Game State Fields** (when adding to GameState):
- `docs/ARCHITECTURE.md` → "State Schema" section
- `docs/API.md` → "GameState" interface

**API Response Fields** (when changing ActionResponse, etc.):
- `docs/API.md` → relevant endpoint section and "Data Models" section

**LLM Prompts** (when changing SYSTEM_PROMPT, OPENING_PROMPT, etc.):
- `docs/LLM_INTEGRATION.md` → "Prompt Architecture" section

## Testing Requirements

### Test Infrastructure
- All new engine code MUST have corresponding tests in `backend/tests/`
- Use the test world fixtures in `backend/tests/fixtures/test_world/` for deterministic testing
- Mock LLM calls for unit tests using `backend/tests/mocks/llm.py`

### Test Structure
```
backend/tests/
├── unit/          # Test components in isolation
├── integration/   # Test component interactions  
├── e2e/           # Real LLM tests (marked @pytest.mark.slow)
└── fixtures/      # Shared test data
```

### Test Conventions
- Test files: `test_<module>.py`
- Use `@pytest.mark.slow` for tests requiring real LLM calls
- Use `@pytest.mark.integration` for multi-component tests
- Run `pytest backend/tests/ -v --ignore=backend/tests/e2e/` for fast feedback

## Two-Phase Engine Architecture

The game engine uses a two-phase action processing loop. See `planning/two-phase-game-loop-spec.md` for the full specification.

### Core Design Principles
1. **Separation of Concerns**: Parsing (Interactor) → Validation → Narration (Narrator)
2. **Deterministic Mechanics**: State changes are validated BEFORE narration
3. **Derived Visibility**: Item visibility is computed from state, not stored
4. **Protocol-Based Components**: Use `engine/protocols.py` interfaces for testability

### Naming Conventions
- Fields ending in `_id` contain **resolved entity IDs** from the world model
- Fields without `_id` may contain raw player descriptions
- Example: `target_id="brass_key"` (resolved) vs `target="the shiny key"` (raw)

### Component Boundaries
| Component | Responsibility | Creates |
|-----------|---------------|---------|
| RuleBasedParser | Fast-path parsing (directions, simple verbs) | ActionIntent |
| InteractorAI | Complex input interpretation | ActionIntent or FlavorIntent |
| ActionValidator | Validate against world rules | ValidationResult |
| VisibilityResolver | Compute what player can see | Used by validators |
| NarratorAI | Generate prose from events | Narrative text |

### Key Models (in `backend/app/models/`)
- `intent.py`: ActionIntent, FlavorIntent, ActionType
- `event.py`: Event, RejectionEvent, EventType  
- `perception.py`: PerceptionSnapshot, VisibleEntity
- `validation.py`: ValidationResult, RejectionCode

## Python Code Design Principles

### Function Design
- **Single Responsibility**: Each function does ONE thing well
- **Length Guideline**: Functions should be <25 lines; if longer, consider splitting
- **Cognitive Complexity**: Avoid deep nesting (max 3 levels); extract helper functions
- **Pure Functions**: Prefer functions without side effects where possible

### Naming Conventions
- **Functions**: `verb_noun` pattern → `validate_intent()`, `build_snapshot()`
- **Private Methods**: Single underscore prefix → `_check_visibility()`
- **Boolean Functions**: `is_`, `has_`, `can_` prefix → `is_item_visible()`, `can_access_location()`
- **Factory Functions**: `create_` or `build_` prefix → `create_processor()`

### Class Design
- **Composition over Inheritance**: Prefer injecting dependencies over deep hierarchies
- **Dependency Injection**: Pass dependencies via `__init__`, not global imports
- **Protocol Compliance**: Implement protocols from `engine/protocols.py` for swappable components

```python
# GOOD: Dependency injection
class TwoPhaseProcessor:
    def __init__(self, parser: ActionParser, validator: IntentValidator):
        self.parser = parser
        self.validator = validator

# BAD: Hard-coded dependencies
class TwoPhaseProcessor:
    def __init__(self):
        self.parser = RuleBasedParser()  # Not testable
```

### Error Handling
- **Explicit over Silent**: Raise exceptions for unexpected states; don't silently fail
- **Custom Exceptions**: Define domain exceptions in `engine/exceptions.py`
- **Result Types**: For expected failures, return `ValidationResult` or `tuple[bool, str]`

```python
# For unexpected errors (bugs)
raise ValueError(f"Unknown action type: {action_type}")

# For expected failures (player did something invalid)
return ValidationResult(valid=False, code="NO_EXIT", reason="...")
```

### Docstrings
- **Required For**: All public functions, classes, and modules
- **Format**: Google style with Args, Returns, Raises sections
- **Examples**: Include usage examples for complex functions

### Module Organization
- **One Concept Per File**: Don't mix unrelated classes
- **Imports at Top**: Standard lib → Third party → Local, separated by blank lines
- **Circular Import Prevention**: Use `TYPE_CHECKING` for type hints only

```python
from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from app.engine.state import GameStateManager
```

### Async Patterns
- **Async All the Way**: Don't mix sync and async in call chains
- **LLM Calls**: Always async; never block the event loop
- **Concurrency**: Use `asyncio.gather()` for parallel LLM calls when possible

### Testing Considerations
- **Testable by Design**: If a function is hard to test, it needs refactoring
- **No Hidden State**: Avoid module-level mutable state
- **Deterministic**: Functions with same input should produce same output (except LLM)

