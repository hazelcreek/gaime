# Multi-Language Support in Gaime

## Executive Summary

This document explores the technical and design considerations for supporting multiple player interaction languages in Gaime, specifically English (default) and German. The scope includes UI elements, narrative generation, and player command processing, while keeping world authoring in English only.

---

## Table of Contents

1. [Scope and Requirements](#scope-and-requirements)
2. [Components Requiring Localization](#components-requiring-localization)
3. [Implementation Options](#implementation-options)
4. [Quality, Consistency, and Tone Analysis](#quality-consistency-and-tone-analysis)
5. [Technical Architecture Considerations](#technical-architecture-considerations)
6. [Recommended Approach](#recommended-approach)
7. [Implementation Roadmap](#implementation-roadmap)
8. [Appendix: German Text Adventure Conventions](#appendix-german-text-adventure-conventions)

---

## Scope and Requirements

### In Scope
- **UI Labels & Elements**: Buttons, headers, placeholders (e.g., "Begin Adventure" → "Abenteuer starten")
- **Narrative Output**: All LLM-generated prose should be in the player's chosen language
- **Command Input**: Player commands in their language (e.g., "gehe nach Norden", "untersuche Gemälde")
- **System Messages**: Loading states, errors, hints (e.g., "The world shifts around you..." → "Die Welt verändert sich um dich...")

### Out of Scope
- World authoring (YAML files remain English-only)
- World Builder tool
- Debug/developer interfaces
- Backend logs and diagnostics

### Design Goals
1. **Seamless Experience**: The player should feel they're playing a native German/English game
2. **Consistent Tone**: The narrative voice should match the world's defined tone regardless of language
3. **Natural Commands**: Players should use natural language constructs in their language, not translated English phrases
4. **Minimal Content Duplication**: Avoid maintaining two sets of YAML files where possible

---

## Components Requiring Localization

### 1. Frontend UI Elements

Current hardcoded strings in the React frontend:

| Component | English String | German Equivalent |
|-----------|----------------|-------------------|
| Terminal.tsx | "Welcome, Traveler" | "Willkommen, Reisender" |
| Terminal.tsx | "Choose your world and prepare for adventure" | "Wähle deine Welt und bereite dich auf das Abenteuer vor" |
| Terminal.tsx | "Your Name" | "Dein Name" |
| Terminal.tsx | "Choose World" | "Welt wählen" |
| Terminal.tsx | "Begin Adventure" | "Abenteuer starten" |
| Terminal.tsx | "Loading worlds..." | "Lade Welten..." |
| Terminal.tsx | "The world shifts around you..." | "Die Welt verändert sich um dich..." |
| Sidebar.tsx | "Location" | "Ort" |
| Sidebar.tsx | "Inventory" | "Inventar" |
| Sidebar.tsx | "Turn" | "Zug" |
| Sidebar.tsx | "Empty" | "Leer" |
| Sidebar.tsx | "Start New Game" | "Neues Spiel" |
| Sidebar.tsx | "Debug Mode" | "Debug-Modus" |
| CommandInput.tsx | Placeholder text | Lokalisierter Platzhaltertext |

**Implementation**: Standard i18n approach with translation files (e.g., react-i18next)

### 2. LLM Narrative Generation

The narrative is generated by the Game Master LLM based on:
- System prompt (English, defines role and world context)
- World data (YAML files, English)
- Player action (now potentially in German)

**Key Question**: Where should translation happen?

### 3. Player Command Processing

Current command normalization in `game_master.py`:

```python
# English-centric normalization
text = re.sub(r'\b(inspect|study|check|view|observe)\b', 'examine', text)
text = re.sub(r'\b(grab|pick up|take|get)\b', 'take', text)
```

German equivalents would need:
```python
# German command synonyms
text = re.sub(r'\b(inspiziere|studiere|prüfe|betrachte|beobachte)\b', 'untersuche', text)
text = re.sub(r'\b(greife|nimm|hole|nehme)\b', 'nimm', text)
```

**Direction Commands**:
| English | German |
|---------|--------|
| north/n | norden/n |
| south/s | süden/s |
| east/e | osten/o |
| west/w | westen/w |
| up/u | hoch/rauf/h |
| down/d | runter/hinunter |

### 4. YAML Content

Current YAML structure (all English):

```yaml
# world.yaml
name: "The Cursed Manor"
premise: |
  A violent storm has driven you to seek shelter...

# items.yaml  
rusty_key:
  name: "Rusty Key"
  description: "An old iron key, covered in rust..."
  found_description: "A rusty key hangs from a nail on the wall."
```

**Question**: Does this need German equivalents, or can LLM translate on-the-fly?

---

## Implementation Options

### Option A: Full Static Localization

**Approach**: Duplicate all content in both languages

**YAML Structure**:
```yaml
rusty_key:
  name:
    en: "Rusty Key"
    de: "Rostiger Schlüssel"
  description:
    en: "An old iron key, covered in rust..."
    de: "Ein alter Eisenschlüssel, mit Rost bedeckt..."
  found_description:
    en: "A rusty key hangs from a nail on the wall."
    de: "Ein rostiger Schlüssel hängt an einem Nagel an der Wand."
```

**Pros**:
- Maximum quality control over every piece of text
- Consistent terminology and tone
- No LLM translation overhead at runtime
- Works even with less capable models

**Cons**:
- Doubles world authoring work
- Requires human translators for quality
- Every world update needs translation sync
- More complex YAML schema
- Not scalable to more languages

**Estimated Effort**: 
- Schema changes: 2-3 days
- Frontend i18n: 1-2 days
- Translating cursed-manor: 2-3 days of translator work
- Per additional world: Similar translation effort

---

### Option B: Full LLM On-the-Fly Translation

**Approach**: Keep all YAML in English, instruct LLM to respond in player's language

**System Prompt Addition**:
```
## Language Instruction
The player has chosen German (de) as their language.
You MUST:
1. Generate ALL narrative in German
2. Interpret player commands in German
3. Maintain the world's tone in German prose
4. Use natural German phrasing, not literal translations
5. Item and location names should be naturally translated
   (e.g., "Rusty Key" → "Rostiger Schlüssel")
```

**Command Processing**:
```python
# Language-agnostic LLM command interpretation
# Instead of regex normalization, let LLM understand intent

user_prompt = f'''
The player action is: "{action}"
The player's language is: {language}

Interpret this action and respond appropriately.
'''
```

**Pros**:
- Zero content duplication
- Instant support for any language the LLM supports
- Scales effortlessly to new languages
- No translator hiring required
- Handles creative variations naturally

**Cons**:
- Quality depends entirely on LLM capabilities
- Potential inconsistency in terminology (same item named differently across sessions)
- Higher token usage (language instruction overhead)
- Risk of "translationese" rather than natural prose
- Model-dependent quality variance (Gemini vs. GPT-4 vs. local Ollama)
- Cannot work with weaker models

**Token Overhead**: ~50-100 additional tokens per request for language instructions

---

### Option C: Hybrid Approach (Recommended)

**Approach**: Localize critical touchpoints, delegate narrative generation to LLM

**Localized (Static)**:
1. Frontend UI strings (i18n files)
2. Item names and key nouns (simple lookup table)
3. Location names (lookup table)
4. Command vocabulary (direction/action mappings)

**LLM-Generated (Dynamic)**:
1. Narrative prose
2. NPC dialogue
3. Descriptions
4. System responses

**Implementation**:

```yaml
# New: translations.yaml per world (or global)
item_names:
  rusty_key:
    en: "Rusty Key"
    de: "Rostiger Schlüssel"
  iron_key:
    en: "Iron Key"  
    de: "Eiserner Schlüssel"

location_names:
  entrance_hall:
    en: "Entrance Hall"
    de: "Eingangshalle"
  dining_room:
    en: "Dining Room"
    de: "Speisezimmer"

# Commands stay language-mapped in code
commands:
  directions:
    north: ["north", "n", "norden", "n"]
    south: ["south", "s", "süden", "s"]
  actions:
    examine: ["examine", "look at", "inspect", "untersuche", "betrachte", "schau an"]
    take: ["take", "get", "pick up", "nimm", "nehme", "hole"]
```

**System Prompt Enhancement**:
```
## Language & Localization
Player language: German (de)
Generate all narrative in German.

Use these official translations for items/locations:
- Rusty Key → Rostiger Schlüssel
- Entrance Hall → Eingangshalle
- [dynamically inserted from translations.yaml]

Maintain consistent German prose matching the tone: {tone}
```

**Pros**:
- Consistent terminology for game-critical elements (items, locations)
- Natural, creative narrative prose via LLM
- Manageable localization effort (just names, not full descriptions)
- Quality baseline with room for model creativity
- Graceful degradation (LLM can improvise if translation missing)

**Cons**:
- Some translation maintenance required
- Still some token overhead
- Command mapping needs maintenance

---

## Quality, Consistency, and Tone Analysis

### Terminology Consistency

**Risk**: Without explicit translation tables, LLM might call the same item different things:
- Turn 1: "Der rostige Schlüssel"
- Turn 5: "Der verrostete Schlüssel"  
- Turn 10: "Der alte Eisenschlüssel"

**Mitigation**: 
- Option C's translation table ensures "rusty_key" is always "Rostiger Schlüssel"
- Include recent narrative in context to reinforce terminology

### Tone Preservation

The world defines tone in `world.yaml`:
```yaml
tone: "atmospheric, mysterious, unsettling yet compelling"
```

**English Example** (from current system):
> "The heavy front door has just slammed shut behind you, pushed by a gust of howling wind. Lightning flashes through the grimy windows..."

**Quality German Equivalent**:
> "Die schwere Eingangstür ist soeben hinter dir ins Schloss gefallen, gestoßen von einer heulenden Windböe. Blitze zucken durch die schmutzigen Fenster..."

**LLM Capability Assessment**:

| Model | German Quality | Tone Preservation | Consistency |
|-------|----------------|-------------------|-------------|
| GPT-4o | Excellent | Excellent | Excellent |
| Gemini Pro | Very Good | Very Good | Good |
| Claude 3.5 | Excellent | Excellent | Excellent |
| Llama 3.1 (local) | Moderate | Moderate | Variable |
| Mistral | Good | Good | Moderate |

Modern frontier models (GPT-4o, Gemini Pro, Claude) produce German prose that is:
- Grammatically correct
- Stylistically appropriate
- Tonally consistent with source material
- Often indistinguishable from human-written German

### Command Understanding

**Challenge**: German has richer morphology:
- "untersuche" (examine - imperative)
- "untersuchen" (examine - infinitive)  
- "untersuchst" (you examine - 2nd person)

**LLM Advantage**: Modern LLMs understand German morphology and intent naturally:
- "schau dir das Gemälde an" → examine painting
- "geh Richtung Norden" → go north
- "nimm den Schlüssel" → take key

**Recommended Approach**: 
1. Map common command stems for reliability
2. Let LLM handle natural language variations
3. Include German command examples in system prompt

### NPC Dialogue Authenticity

Victorian/Gothic setting with German:
- Jenkins (butler) should speak formal German ("Sie" form)
- Ghost child should speak simpler German
- Lady Margaret should speak fragmented, poetic German

**Prompt Enhancement**:
```
## German Speech Patterns
- Jenkins speaks formal German using "Sie" (formal you)
- The Ghost Child uses simple vocabulary (as a child would)
- Lady Margaret speaks fragmented, poetic 19th-century German
```

---

## Technical Architecture Considerations

### Backend Changes

```python
# models/game.py
class GameState(BaseModel):
    # ... existing fields ...
    language: str = "en"  # ISO 639-1 code

# New: API accepts language parameter
@router.post("/new")
async def new_game(world_id: str, player_name: str, language: str = "en"):
    ...
```

### Frontend Changes

```typescript
// i18n setup (react-i18next)
// src/i18n/en.json
{
  "welcome": "Welcome, Traveler",
  "chooseWorld": "Choose your world and prepare for adventure",
  ...
}

// src/i18n/de.json
{
  "welcome": "Willkommen, Reisender",
  "chooseWorld": "Wähle deine Welt und bereite dich auf das Abenteuer vor",
  ...
}

// Language selector in Terminal.tsx welcome screen
<select value={language} onChange={setLanguage}>
  <option value="en">English</option>
  <option value="de">Deutsch</option>
</select>
```

### System Prompt Modification

```python
LANGUAGE_INSTRUCTION = '''
## Language
The player has chosen {language_name} ({language_code}) as their language.
Generate ALL narrative responses in {language_name}.

Official terminology:
{translation_table}

Interpret player commands in {language_name}.
Example valid commands in {language_name}:
{command_examples}

Maintain natural {language_name} prose matching the world's tone.
'''
```

### Translation Loading

```python
# translations.py
class TranslationManager:
    def __init__(self, language: str, world_id: str):
        self.language = language
        self.translations = self._load_translations(world_id)
    
    def _load_translations(self, world_id: str) -> dict:
        # Load from worlds/{world_id}/translations.yaml
        # Fall back to global translations if not found
        ...
    
    def get_item_name(self, item_id: str) -> str:
        return self.translations.get("items", {}).get(item_id, {}).get(
            self.language, item_id
        )
    
    def get_location_name(self, location_id: str) -> str:
        return self.translations.get("locations", {}).get(location_id, {}).get(
            self.language, location_id
        )
    
    def build_terminology_prompt(self) -> str:
        """Build prompt section with official translations"""
        ...
```

---

## Recommended Approach

Based on the analysis, we recommend **Option C (Hybrid Approach)** with the following specifics:

### Phase 1: Foundation
1. **Add language to GameState** - Track player's chosen language
2. **Frontend i18n** - Implement react-i18next for all UI strings
3. **Language selector** - Add to welcome screen

### Phase 2: LLM Integration  
1. **System prompt language instruction** - Dynamic section based on language
2. **Translation table structure** - Create `translations.yaml` schema
3. **Command vocabulary mapping** - Expand normalization for German

### Phase 3: Content
1. **Create translations for cursed-manor** - Item names, location names
2. **Document German command examples** - For system prompt
3. **Test and iterate** - Quality review with native speakers

### Why This Approach

1. **Pragmatic Balance**: Critical terms are consistent, prose is creative
2. **Manageable Scope**: ~50-100 terms to translate per world, not thousands of words
3. **Leverages LLM Strength**: Modern LLMs excel at German prose generation
4. **Extensible**: Adding Spanish/French later requires same pattern
5. **Graceful Degradation**: Works even if some translations are missing

---

## Implementation Roadmap

### Sprint 1: Infrastructure (3-4 days)
- [ ] Add `language` field to `GameState` model
- [ ] Implement `TranslationManager` class
- [ ] Create translation file schema and loader
- [ ] Add language parameter to `/api/game/new` endpoint

### Sprint 2: Frontend (2-3 days)
- [ ] Install and configure react-i18next
- [ ] Create en.json and de.json translation files
- [ ] Add language selector to welcome screen
- [ ] Persist language choice (localStorage)
- [ ] Translate all UI components

### Sprint 3: LLM Integration (2-3 days)
- [ ] Add language instruction template to system prompt
- [ ] Build terminology table injection
- [ ] Expand command normalization for German
- [ ] Add German command examples to prompts
- [ ] Test narrative generation quality

### Sprint 4: Content & Testing (3-4 days)
- [ ] Create `translations.yaml` for cursed-manor
- [ ] Create German command vocabulary list
- [ ] Quality review with German speaker
- [ ] Iterate on prompt refinements
- [ ] Documentation updates

**Total Estimated Effort**: 10-14 days

---

## Appendix: German Text Adventure Conventions

### Standard Command Vocabulary

| Category | German Commands | Notes |
|----------|-----------------|-------|
| **Movement** | gehe/geh, laufe/lauf, bewege dich | "gehe nach Norden" or "geh n" |
| **Directions** | norden (n), süden (s), osten (o), westen (w), hoch/rauf, runter/hinunter | Abbreviations in parentheses |
| **Examine** | untersuche, betrachte, schau an/dir an, inspiziere | "untersuche Gemälde" |
| **Take** | nimm, nehme, greife, hole | "nimm Schlüssel" |
| **Use** | benutze, verwende | "benutze Schlüssel mit Tür" |
| **Talk** | sprich mit, rede mit, unterhalte dich mit | "sprich mit Jenkins" |
| **Inventory** | Inventar, zeige Inventar, was habe ich | "Inventar" |
| **Look** | schau, schau dich um, umsehen | "schau dich um" |
| **Help** | Hilfe, hilf mir | "Hilfe" |

### Du vs. Sie Form

Text adventures traditionally use "du" (informal you) for player address:
- "Du siehst einen rostigen Schlüssel." (You see a rusty key.)
- "Du betrittst die Eingangshalle." (You enter the entrance hall.)

NPCs may use either form depending on relationship:
- Jenkins (formal): "Kann ich Ihnen behilflich sein?" (May I help you?)
- Ghost child (informal): "Hilf mir!" (Help me!)

### Gothic/Victorian German Prose

Example atmosphere text:
> "Du betrittst die verdunkelte Bibliothek. Schwere Samtvorhänge verschlucken das letzte Licht des sterbenden Tages. Der Geruch von altem Leder und Verfall liegt schwer in der Luft. Irgendwo in den Schatten tickt eine Uhr, ihr Rhythmus wie ein schwacher Herzschlag in der Stille."

Key stylistic elements:
- Longer, flowing sentences
- Rich sensory descriptions
- Poetic word choices (sterbender Tag, schwacher Herzschlag)
- Formal yet atmospheric register

---

## Conclusion

Multi-language support in Gaime is feasible with modern LLM capabilities. The hybrid approach (Option C) offers the best balance of quality control and development efficiency. By localizing critical terminology while leveraging LLM capabilities for prose generation, we can deliver a natural German gameplay experience without the burden of full content duplication.

The key insight is that LLMs are excellent at stylistic prose generation in German, but consistency requires explicit terminology anchoring. This hybrid model plays to both strengths: human-curated accuracy for game-critical terms, AI-generated creativity for immersive narrative.

Future extensions to additional languages (French, Spanish, etc.) would follow the same pattern with minimal architectural changes—primarily new translation files and command vocabulary mappings.
